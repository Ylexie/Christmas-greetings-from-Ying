
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Particle Christmas Card (Enhanced Santa)</title>
    
    <!-- Load Three.js (r128) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load MediaPipe Hands and related utilities -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <!-- Load Tone.js for background music -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <style>
        /* Pure CSS Styles */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #05051a; /* Matches Three.js background */
            color: #ffffff;
        }

        #three-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* Video Preview Container (Top Right) */
        #video-container {
            position: absolute;
            top: 1rem;
            right: 1rem;
            width: 160px; /* Reduced size */
            height: 120px; /* Reduced size */
            z-index: 20;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            transform: scaleX(-1); /* Horizontal video flip */
            border: 2px solid rgba(66, 133, 244, 0.7);
        }
        
        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* Control Panel (Top Center) */
        #controls {
            position: absolute;
            top: 0.5rem; 
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            padding: 0.8rem 1.5rem; 
            background: rgba(17, 24, 39, 0.85);
            backdrop-filter: blur(5px);
            border-radius: 12px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 1rem; 
        }

        h1 {
            font-size: 1rem; 
            font-weight: 700;
            color: #4285F4;
            margin: 0;
        }

        button {
            padding: 0.4rem 0.8rem; 
            background-color: #34A853;
            color: white;
            font-weight: 600;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            font-size: 0.85rem;
        }
        button:hover {
            background-color: #2e8b49;
            transform: translateY(-1px);
        }
        button:disabled {
            background-color: #555;
            cursor: default;
        }

        #status {
            font-size: 0.75rem; 
            color: #bbb;
            margin: 0;
        }
        
        /* Message Overlay - Default (Bottom Right - for instructions) */
        #message-overlay {
            position: absolute;
            bottom: 1rem; 
            right: 1rem;  
            z-index: 40;
            padding: 1.5rem 2.5rem;
            max-width: 300px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(8px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            text-align: right;
            font-size: 1.1rem; 
            line-height: 1.6;
            font-weight: 500;
            pointer-events: none;
            transition: opacity 0.5s, all 0.5s ease-in-out; 
            opacity: 0; /* Hidden by default */
            white-space: pre-wrap;
        }

        /* New CSS for Centered Greeting (Full text display) */
        #message-overlay.centered-greeting {
            bottom: auto;
            top: 50%;
            left: 50%;
            right: auto;
            transform: translate(-50%, -50%);
            max-width: 80%; /* Wider display */
            padding: 3rem;
            text-align: center;
            font-size: 1.5rem; /* Larger font */
            line-height: 1.8;
            background: rgba(17, 24, 39, 0.9); /* Deeper, more solid background */
            border-radius: 15px; 
        }

        #reset-button {
            position: absolute;
            bottom: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 50;
            padding: 0.6rem 1.2rem;
            background-color: #EA4335;
            color: white;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        #reset-button.visible {
            opacity: 1;
            pointer-events: auto;
        }

        @media (max-width: 600px) {
            #video-container {
                top: 0.5rem;
                right: 0.5rem;
                width: 120px;
                height: 90px;
            }
            #controls {
                flex-direction: column;
                padding: 0.5rem 1rem;
                gap: 0.5rem;
            }
            h1 {
                font-size: 0.9rem;
            }
            button {
                font-size: 0.75rem;
                padding: 0.3rem 0.6rem;
            }
            #message-overlay {
                font-size: 0.9rem;
                padding: 1rem 1.5rem;
                max-width: 250px;
            }
            #message-overlay.centered-greeting {
                font-size: 1.2rem;
                padding: 2rem;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Control Panel -->
    <div id="controls">
        <h1>3D Particle Christmas Card</h1>
        <button id="start-button">
            Enable Camera / Start Tracking (Play Music)
        </button>
        <p id="status">Status: Waiting to start...</p>
    </div>

    <!-- Message Overlay (Bottom Right) -->
    <div id="message-overlay">
        <!-- Initial content set by JS -->
    </div>

    <!-- Reset Scene Button -->
    <button id="reset-button">Reset Scene</button>

    <!-- 3D Three.js Container -->
    <div id="three-container"></div>

    <!-- MediaPipe Video Input and Drawing Canvas -->
    <div id="video-container">
        <video id="input_video" class="hidden"></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <script>
        // --- Global Three.js Variables ---
        let scene, camera, renderer;
        let christmasTree; // The main particle object
        let particles; // Background stars
        let sleighParticles; // Santa's sleigh particle cluster (reindeer/gifts)
        let santa1, santa2; // The two new Santa Claus figures
        
        // --- Music Variables (Tone.js) ---
        let synth;
        let melody;
        
        // --- State Management ---
        const STATES = {
            INIT: 'INIT',
            TRACKING: 'TRACKING',
            OK_HOLDING: 'OK_HOLDING',
            DISPERSING: 'DISPERSING',
            CARD_SHOWN: 'CARD_SHOWN'
        };
        let appState = STATES.INIT;
        let okGestureStartTime = 0;
        const OK_DEBOUNCE_TIME = 400; // Milliseconds to hold the OK gesture

        // --- Hand Tracking & Smoothing ---
        let smoothedTargetAngle = 0;
        let smoothedWristZ = 0.5;
        let smoothedTargetX = 0; 
        let smoothedTargetY = 0; 
        
        const EASING_FACTOR = 0.3; 
        const SMOOTHING_ALPHA = 0.2; 
        const POSITION_SMOOTHING_ALPHA = 0.05; 

        // --- Particle Dispersion/Gathering Control (New) ---
        let randomDisplacementVectors = []; // Stores the fixed random direction for each particle
        let currentParticleDispersion = 0.0; // 0.0 for gathered (fist), 1.0 for dispersed (open hand)
        const MAX_LOCAL_DISPERSION_RADIUS = 0.5; // Max radius for local particle spread (Three.js units)
        const DISPERSION_EASING = 0.1; // Smoothness factor for dispersion/gathering
        
        // --- DOM Elements ---
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusElement = document.getElementById('status');
        const startButton = document.getElementById('start-button');
        const messageOverlay = document.getElementById('message-overlay');
        const resetButton = document.getElementById('reset-button');
        
        // --- Dispersion Data ---
        let originalTreePositions;
        let dispersedTargetData = [];
        let currentGreetingText = ""; // Store the selected text
        
        // Greetings List
        const GREETINGS = [
            "HOORAY! Sending you explosive Christmas joy and a dazzling New Year!",
            "Get ready to celebrate! Wishing you the happiest, sparkliest holiday season!",
            "Wishes granted! May your holidays be WILDLY bright and unbelievably festive!",
            "LET'S GO! Time for cheer, gifts, and a fantastic adventure into the New Year!",
            "Unwrap the fun! Wishing you massive smiles and endless holiday energy!",
            "Ready for a blast? Merry, merry Christmas and a super-charged New Year!",
            "Santa's Sleigh has arrived! May your holiday be filled with surprises and joy! Merry Christmas!",
            "Dash away! The reindeer are ready! Sending you the brightest Christmas blessings and New Year wishes!",
            "Jingle bells! Santa Claus is coming with a sleigh full of happiness and gifts just for you!"
        ];
        let lastGreetingIndex = -1;

        /**
         * Selects a new, unique greeting text.
         */
        function selectNewGreeting() {
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * GREETINGS.length);
            } while (newIndex === lastGreetingIndex);
            
            lastGreetingIndex = newIndex;
            return GREETINGS[newIndex];
        }

        // --- Tone.js Music Setup ---
        function setupMusic() {
            const reverb = new Tone.Reverb({
                decay: 3, 
                wet: 0.4
            }).toDestination(); 

            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" }, 
                envelope: {
                    attack: 0.02,
                    decay: 0.8,    
                    sustain: 0.2,
                    release: 1.5   
                },
                volume: -8
            }).connect(reverb);
            
            const notes = [
                { time: "0:0:0", note: "E4", duration: "4n" }, { time: "0:1:0", note: "E4", duration: "4n" }, { time: "0:2:0", note: "E4", duration: "2n" },
                { time: "1:0:0", note: "E4", duration: "4n" }, { time: "1:1:0", note: "E4", duration: "4n" }, { time: "1:2:0", note: "E4", duration: "2n" },
                { time: "2:0:0", note: "E4", duration: "4n" }, { time: "2:1:0", note: "G4", duration: "4n" }, { time: "2:2:0", note: "C4", duration: "4n" },
                { time: "2:3:0", note: "D4", duration: "4n" }, { time: "3:0:0", note: "E4", duration: "1n" }, 
                { time: "4:0:0", note: "F4", duration: "4n" }, { time: "4:1:0", note: "F4", duration: "4n" }, { time: "4:2:0", note: "F4", duration: "8n" },
                { time: "4:2:2", note: "F4", duration: "8n" }, { time: "5:0:0", note: "F4", duration: "4n" }, { time: "5:1:0", note: "E4", duration: "4n" },
                { time: "5:2:0", note: "E4", duration: "8n" }, { time: "5:2:2", note: "E4", duration: "8n" }, { time: "6:0:0", note: "D4", duration: "4n" },
                { time: "6:1:0", note: "D4", duration: "4n" }, { time: "6:2:0", note: "E4", duration: "4n" }, { time: "6:3:0", note: "D4", duration: "4n" },
                { time: "7:0:0", note: "G4", duration: "1n" },
            ];

            melody = new Tone.Part((time, value) => {
                synth.triggerAttackRelease(value.note, value.duration, time);
            }, notes).start(0);

            Tone.Transport.bpm.value = 120;
            melody.loop = true;
            melody.loopEnd = '8m'; 
            
            Tone.Transport.start();
        }

        // --- ENHANCED: Santa Particle Figure Generation ---
        /**
         * Generates a particle figure resembling Santa Claus using multiple clusters.
         * Improved function, using clearer shapes to define Santa.
         * @returns {THREE.Group} A group containing the particle systems for Santa.
         */
        function createSantaParticles() {
            const group = new THREE.Group();
            const bodyCount = 1200; // Body particle count
            const hatCount = 800;    // Hat particle count
            const trimCount = 1500;  // Beard/Trim particle count (white parts)
            
            const colorRed = new THREE.Color(0xFF0000);
            const colorWhite = new THREE.Color(0xFFFFFF);

            // 1. Body and Hat (Red)
            const redGeometry = new THREE.BufferGeometry();
            const redPositions = [];
            const redColors = [];
            const santaHeight = 2.0;
            const bodyRadius = 0.8;

            for (let i = 0; i < bodyCount + hatCount; i++) {
                let x, y, z;
                
                if (i < bodyCount) {
                    // Body Shape (Approximate Cylinder/Oval)
                    y = (Math.random() * 1.0) - 1.0; // From -1.0 to 0.0
                    const r = Math.random() * bodyRadius * (1 - Math.abs(y * 0.5));
                    const angle = Math.random() * Math.PI * 2;
                    x = Math.cos(angle) * r;
                    z = Math.sin(angle) * r;
                } else {
                    // Hat Shape (Cone, above Y=0.0)
                    y = Math.random() * 1.0 + 0.05; // From 0.05 to 1.05
                    const heightFactor = 1.0 - (y - 0.05) / 1.0;
                    const r = Math.random() * 0.4 * heightFactor; // Conical contraction
                    const angle = Math.random() * Math.PI * 2;
                    x = Math.cos(angle) * r;
                    z = Math.sin(angle) * r;
                }
                
                redPositions.push(x, y, z);
                redColors.push(colorRed.r, colorRed.g, colorRed.b);
            }
            redGeometry.setAttribute('position', new THREE.Float32BufferAttribute(redPositions, 3));
            redGeometry.setAttribute('color', new THREE.Float32BufferAttribute(redColors, 3));
            const redMaterial = new THREE.PointsMaterial({ size: 0.08, vertexColors: true, blending: THREE.AdditiveBlending });
            const redPoints = new THREE.Points(redGeometry, redMaterial);
            group.add(redPoints);

            // 2. Beard, Trim, and Pom-Pom (White)
            const whiteGeometry = new THREE.BufferGeometry();
            const whitePositions = [];
            const whiteColors = [];

            for (let i = 0; i < trimCount; i++) {
                let x, y, z;
                
                if (i < trimCount * 0.6) {
                    // Beard and Jacket Trim around y=-0.1 to y=0.1
                    y = (Math.random() * 0.2) - 0.1; 
                    const r = bodyRadius * 1.1 + Math.random() * 0.1;
                    const angle = Math.random() * Math.PI * 2;
                    x = Math.cos(angle) * r;
                    z = Math.sin(angle) * r * 0.6; // Elliptical shape, increasing 3D feel
                } else if (i < trimCount * 0.9) {
                    // Hat Trim around y=0.0 to y=0.1
                    y = Math.random() * 0.1 + 0.0;
                    const r = bodyRadius * 0.5 + Math.random() * 0.15;
                    const angle = Math.random() * Math.PI * 2;
                    x = Math.cos(angle) * r;
                    z = Math.sin(angle) * r;
                } else {
                    // Pom-Pom on top
                    y = 1.05 + Math.random() * 0.1;
                    const r = Math.random() * 0.1;
                    const angle = Math.random() * Math.PI * 2;
                    x = Math.cos(angle) * r;
                    z = Math.sin(angle) * r;
                }

                whitePositions.push(x, y, z);
                whiteColors.push(colorWhite.r, colorWhite.g, colorWhite.b);
            }
            whiteGeometry.setAttribute('position', new THREE.Float32BufferAttribute(whitePositions, 3));
            whiteGeometry.setAttribute('color', new THREE.Float32BufferAttribute(whiteColors, 3));
            const whiteMaterial = new THREE.PointsMaterial({ size: 0.06, vertexColors: true, blending: THREE.AdditiveBlending });
            const whitePoints = new THREE.Points(whiteGeometry, whiteMaterial);
            group.add(whitePoints);
            
            // Adjust the whole figure's base position
            group.position.y = 0; 
            return group;
        }

        // --- Other Particle Generation ---
        function createParticleTree() {
             // Christmas tree particle creation logic
            const pGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color();
            
            const treeHeight = 2.5;
            const baseRadius = 1.2;
            const particleCount = 5000;
            
            // Clear the array before population
            randomDisplacementVectors = []; 

            for (let i = 0; i < particleCount; i++) {
                const y = (Math.random() * treeHeight) - 2.0; 
                const radiusAtY = baseRadius * (1 - (y + 2.0) / treeHeight);
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * radiusAtY * 0.9; 

                positions.push(Math.cos(angle) * radius, y, Math.sin(angle) * radius);

                // Calculate and store random displacement vector (for local dispersion)
                const randX = (Math.random() - 0.5) * 2;
                const randY = (Math.random() - 0.5) * 2;
                const randZ = (Math.random() - 0.5) * 2;
                const randVector = new THREE.Vector3(randX, randY, randZ).normalize();
                randomDisplacementVectors.push(randVector.x, randVector.y, randVector.z);

                const rand = Math.random();
                if (rand < 0.15) {
                    if (rand < 0.04) {
                        color.set(0xFF0000); 
                    } else if (rand < 0.08) {
                        color.set(0xFFD700); 
                    } else if (rand < 0.12) {
                        color.set(0x4285F4); 
                    } else {
                        color.set(0xFFFFFF); 
                    }
                } else {
                    color.setHSL(
                        0.3 + Math.random() * 0.1, 
                        0.8, 
                        0.6 + Math.random() * 0.2 
                    );
                }
                colors.push(color.r, color.g, color.b);
            }
            
            pGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            pGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            // Save original positions before any manipulation
            originalTreePositions = new Float32Array(positions);

            const pMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.9,
                blending: THREE.AdditiveBlending,
            });

            const tree = new THREE.Points(pGeometry, pMaterial);
            tree.position.y = 0.5;
            return tree;
        }

        function createStars() {
            // Background stars creation logic
            const starCount = 4000;
            const pGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(starCount * 3);
            const colors = [];
            const color = new THREE.Color();
            
            const brightColors = [0xFF4500, 0xDA70D6, 0x00BFFF, 0xFFD700, 0xADFF2F, 0xFFFFFF,];

            for (let i = 0; i < starCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 40;
                positions[i + 1] = (Math.random() - 0.5) * 40;
                positions[i + 2] = (Math.random() - 0.5) * 40;

                const randomColorHex = brightColors[Math.floor(Math.random() * brightColors.length)];
                color.set(randomColorHex);
                colors.push(color.r, color.g, color.b);
            }

            pGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            pGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const pMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.7,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
            });

            return new THREE.Points(pGeometry, pMaterial);
        }
        
        function createSleighParticles() {
            // Sleigh particle cluster creation logic
            const sleighCount = 800; 
            const pGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const color = new THREE.Color();
            
            const boxSizeX = 2.0; 
            const boxSizeY = 0.5; 
            const boxSizeZ = 0.5; 

            for (let i = 0; i < sleighCount; i++) {
                const x = (Math.random() - 0.5) * boxSizeX;
                const y = (Math.random() - 0.5) * boxSizeY;
                const z = (Math.random() - 0.5) * boxSizeZ;

                positions.push(x, y, z);

                if (i % 2 === 0) {
                    color.set(0xFF0000); 
                } else {
                    color.set(0xFFFFFF); 
                }
                colors.push(color.r, color.g, color.b);
            }
            
            pGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            pGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

            const pMaterial = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,
            });

            const sleigh = new THREE.Points(pGeometry, pMaterial);
            sleigh.position.set(5, 1.5, 0); 
            return sleigh;
        }

        /**
         * Initializes the Three.js scene, camera, renderer, and objects.
         */
        function initThree() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000033); 
            scene.fog = new THREE.Fog(0x000033, 1, 15);

            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);
            camera.position.z = 5;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('three-container').appendChild(renderer.domElement);
            
            scene.add(new THREE.AmbientLight(0xeeeeee, 2.5));

            // 1. Core Objects
            christmasTree = createParticleTree();
            scene.add(christmasTree);
            particles = createStars();
            scene.add(particles);
            sleighParticles = createSleighParticles(); 
            scene.add(sleighParticles); 
            
            // 2. Santa particle figures
            santa1 = createSantaParticles();
            santa2 = createSantaParticles();
            
            // Initial positioning and hiding
            santa1.position.set(-5, 0, 0); // Adjust position to be closer to screen edges
            santa2.position.set(5, 0, 0);
            santa1.visible = false;
            santa2.visible = false;
            
            scene.add(santa1);
            scene.add(santa2);

            currentGreetingText = selectNewGreeting();

            window.addEventListener('resize', onWindowResize, false);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // --- Disperse and Reset Logic ---
        
        /**
         * Prepares for the tree dispersal animation.
         */
        function prepareDispersal() {
            const positions = christmasTree.geometry.attributes.position.array;
            dispersedTargetData = [];
            const numParticles = positions.length / 3;
            
            // All tree particles scatter outwards randomly
            for (let i = 0; i < numParticles; i++) {
                const target = new THREE.Vector3();
                
                target.set(
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30,
                    (Math.random() - 0.5) * 30
                );
                
                dispersedTargetData.push({ 
                    target: target, 
                });
            }
            
            messageOverlay.textContent = "Unlocking your Christmas blessing...";
            messageOverlay.style.opacity = 1;
            messageOverlay.classList.remove('centered-greeting');
        }

        /**
         * Resets the scene to the initial tree state.
         */
        function resetScene() {
            currentGreetingText = selectNewGreeting();
            
            appState = STATES.TRACKING;
            statusElement.textContent = "Status: Tracking... Please make the OK gesture, or use your hand to spread/gather the particles.";
            messageOverlay.textContent = "Make the 'OK' gesture in front of the camera to unlock your Christmas blessing! Open your hand to disperse particles, make a fist to gather them.";
            messageOverlay.style.opacity = 1;
            messageOverlay.classList.remove('centered-greeting'); 

            resetButton.classList.remove('visible');

            // Hide Santa and sleigh
            santa1.visible = false;
            santa2.visible = false;

            // Reset local dispersion and show tree
            currentParticleDispersion = 0.0;
            christmasTree.visible = true; 
        }

        // --- Gesture Detection ---
        
        /**
         * Checks for the OK gesture (thumb and index finger forming a circle).
         */
        function checkOKGesture(landmarks) {
            const l = landmarks;
            const THUMB_TIP = 4;
            const INDEX_TIP = 8;
            
            const thumbTip = new THREE.Vector3(l[THUMB_TIP].x, l[THUMB_TIP].y, l[THUMB_TIP].z);
            const indexTip = new THREE.Vector3(l[INDEX_TIP].x, l[INDEX_TIP].y, l[INDEX_TIP].z);
            const distance = thumbTip.distanceTo(indexTip);

            const DISTANCE_THRESHOLD = 0.03; 
            if (distance > DISTANCE_THRESHOLD) return false;

            const MIDDLE_PIP = 6;
            const RING_PIP = 10;
            const PINKY_PIP = 14;

            const middleTipY = l[12].y;
            const middlePipY = l[MIDDLE_PIP].y;
            const ringTipY = l[16].y;
            const ringPipY = l[RING_PIP].y;
            const pinkyTipY = l[20].y;
            const pinkyPipY = l[PINKY_PIP].y;
            
            const EXTENSION_THRESHOLD = 0.05; 
            
            const middleExtended = (middlePipY - middleTipY) > EXTENSION_THRESHOLD;
            const ringExtended = (ringPipY - ringTipY) > EXTENSION_THRESHOLD;
            const pinkyExtended = (pinkyPipY - pinkyTipY) > EXTENSION_THRESHOLD;

            const extendedCount = (middleExtended ? 1 : 0) + (ringExtended ? 1 : 0) + (pinkyExtended ? 1 : 0);
            
            return extendedCount >= 2;
        }

        /**
         * Checks if the hand is closed (a fist) by checking if the tips of non-thumb fingers are bent inward.
         */
        function isHandClosed(landmarks) {
            // Normalized Y difference threshold for a finger to be considered "bent"
            const CLOSED_THRESHOLD_Y = 0.15; 
            
            // Check if tips are close to their MCPs (Fingers bent)
            // Index Tip (8), Index MCP (5)
            const indexClosed = (landmarks[5].y - landmarks[8].y) < CLOSED_THRESHOLD_Y; 
            // Middle Tip (12), Middle MCP (9)
            const middleClosed = (landmarks[9].y - landmarks[12].y) < CLOSED_THRESHOLD_Y; 
            // Ring Tip (16), Ring MCP (13)
            const ringClosed = (landmarks[13].y - landmarks[16].y) < CLOSED_THRESHOLD_Y; 
            // Pinky Tip (20), Pinky MCP (17)
            const pinkyClosed = (landmarks[17].y - landmarks[20].y) < CLOSED_THRESHOLD_Y; 
            
            // It's considered a fist if at least 3 of the 4 non-thumb fingers are closed
            return (indexClosed ? 1 : 0) + (middleClosed ? 1 : 0) + (ringClosed ? 1 : 0) + (pinkyClosed ? 1 : 0) >= 3;
        }


        // --- MediaPipe Hand Handler ---
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            const hasHand = results.multiHandLandmarks && results.multiHandLandmarks.length > 0;

            if (hasHand) {
                const landmarks = results.multiHandLandmarks[0];
                
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#FFD700', lineWidth: 2 });
                drawLandmarks(canvasCtx, landmarks, { color: '#EA4335', lineWidth: 1, radius: 3 });

                if (appState === STATES.TRACKING || appState === STATES.OK_HOLDING) {
                    
                    const wrist = landmarks[0]; 
                    
                    const middleMcp = landmarks[9]; 
                    const dx = middleMcp.x - wrist.x;
                    const dy = middleMcp.y - wrist.y; 
                    const currentAngle = Math.atan2(-dy, dx); 
                    
                    let diff = currentAngle - smoothedTargetAngle;
                    while (diff > Math.PI) diff -= 2 * Math.PI;
                    while (diff < -Math.PI) diff += 2 * Math.PI;
                    smoothedTargetAngle += diff * SMOOTHING_ALPHA;

                    smoothedWristZ = smoothedWristZ * (1 - SMOOTHING_ALPHA) + wrist.z * SMOOTHING_ALPHA;
                    let newScale = 4.0 - (smoothedWristZ * 10.0); 
                    newScale = Math.max(0.3, Math.min(4.0, newScale));

                    const targetX = (wrist.x - 0.5) * 3.0; 
                    const targetYOffset = (0.5 - wrist.y) * 1.0; 
                    
                    smoothedTargetX += (targetX - smoothedTargetX) * POSITION_SMOOTHING_ALPHA;
                    smoothedTargetY += (targetYOffset - smoothedTargetY) * POSITION_SMOOTHING_ALPHA;

                    if (christmasTree && christmasTree.visible) {
                        christmasTree.scale.x += (newScale - christmasTree.scale.x) * EASING_FACTOR;
                        christmasTree.scale.y += (newScale - christmasTree.scale.y) * EASING_FACTOR;
                        christmasTree.scale.z += (newScale - christmasTree.scale.z) * EASING_FACTOR;
                    }
                    
                    const isOk = checkOKGesture(landmarks);
                    const currentTime = performance.now();

                    if (isOk) {
                        if (appState === STATES.TRACKING) {
                            appState = STATES.OK_HOLDING;
                            okGestureStartTime = currentTime;
                            statusElement.textContent = "Status: OK gesture detected... Hold it!";
                        } else if (appState === STATES.OK_HOLDING && (currentTime - okGestureStartTime) >= OK_DEBOUNCE_TIME) {
                            appState = STATES.DISPERSING;
                            statusElement.textContent = "Status: Unlocking Christmas blessing...";
                            prepareDispersal();
                        }
                        // If OK gesture is held, override particle dispersion/gathering
                        currentParticleDispersion = currentParticleDispersion * (1 - DISPERSION_EASING) + 0.5 * DISPERSION_EASING; // Neutral state
                        
                    } else if (appState === STATES.OK_HOLDING) {
                        appState = STATES.TRACKING;
                        statusElement.textContent = "Status: Tracking... Please make the OK gesture, or use your hand to spread/gather the particles.";
                    }
                    
                    // NEW: Particle Dispersion/Gathering (only if not doing the big OK gesture)
                    if (appState === STATES.TRACKING) {
                        const isFist = isHandClosed(landmarks);
                        
                        if (isFist) {
                            // Gradually gather particles (decrease dispersion towards 0.0)
                            currentParticleDispersion = currentParticleDispersion * (1 - DISPERSION_EASING) + 0.0 * DISPERSION_EASING;
                            statusElement.textContent = "Status: Fist detected! Particles gathering (Compressing)...";
                        } else {
                            // Assume "open hand" or relaxed if not OK and not fist
                            // Gradually disperse particles (increase dispersion towards 1.0)
                            currentParticleDispersion = currentParticleDispersion * (1 - DISPERSION_EASING) + 1.0 * DISPERSION_EASING;
                            statusElement.textContent = "Status: Open hand detected! Particles dispersing (Spreading)...";
                        }
                    }

                }
            } else if (appState === STATES.TRACKING || appState === STATES.OK_HOLDING) {
                appState = STATES.TRACKING;
                statusElement.textContent = "Status: Hand tracking... (Hand not visible)";
                // Reset dispersion slowly if hand is lost
                currentParticleDispersion = currentParticleDispersion * (1 - DISPERSION_EASING) + 0.5 * DISPERSION_EASING; // Move to neutral/default
            }
            
            canvasCtx.restore();
        }


        // --- Three.js Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // 1. Background star movement and twinkling effect
            particles.rotation.y += 0.05 * delta;
            particles.rotation.x += 0.02 * delta;

            if (particles.material) {
                particles.material.size = 0.1 + Math.sin(time * 5) * 0.03; 
                particles.material.opacity = 0.7 + Math.sin(time * 3) * 0.3; 
            }
            
            // 2. Sleigh orbit and bobbing
            if (sleighParticles) {
                const orbitRadius = 8; 
                const speed = 0.1; 
                const bobbingHeight = 0.5; 
                
                sleighParticles.rotation.y += 0.02; 
                
                sleighParticles.position.x = Math.cos(time * speed) * orbitRadius;
                sleighParticles.position.z = Math.sin(time * speed) * orbitRadius;
                sleighParticles.position.y = 1.5 + Math.sin(time * 0.5) * bobbingHeight; 
            }

            // 3. Santa particle bobbing (when visible)
            if (santa1.visible) {
                const bobY = Math.sin(time * 1.5) * 0.2; // Subtle vertical bobbing
                santa1.position.y = bobY; 
                santa2.position.y = bobY;

                santa1.rotation.y += 0.005; // Slight rotation
                santa2.rotation.y -= 0.005; // Slight reverse rotation
            }


            // 4. Tree/Card Interaction Logic
            if (christmasTree && dispersedTargetData.length > 0) {
                const isMovingToDispersal = appState === STATES.DISPERSING;
                
                if (isMovingToDispersal) {
                    const positions = christmasTree.geometry.attributes.position.array;
                    let particlesMoved = 0;
                    const DISPERSAL_COMPLETE_DISTANCE = 0.5; 
                    
                    for (let i = 0; i < dispersedTargetData.length; i++) {
                        const data = dispersedTargetData[i];
                        const index3 = i * 3;
                        
                        let targetX, targetY, targetZ;
                        
                        // Move to widely dispersed positions
                        targetX = data.target.x;
                        targetY = data.target.y;
                        targetZ = data.target.z;

                        let currentPos = new THREE.Vector3(positions[index3], positions[index3 + 1], positions[index3 + 2]);
                        const targetPos = new THREE.Vector3(targetX, targetY, targetZ);
                        
                        currentPos.lerp(targetPos, 0.05);
                        
                        positions[index3] = currentPos.x;
                        positions[index3 + 1] = currentPos.y;
                        positions[index3 + 2] = currentPos.z;

                        if (currentPos.distanceTo(targetPos) < DISPERSAL_COMPLETE_DISTANCE) {
                            particlesMoved++;
                        }
                    }
                    
                    if (particlesMoved >= dispersedTargetData.length) {
                            appState = STATES.CARD_SHOWN;
                            // Tree particles disperse, invisible
                            christmasTree.visible = false; 
                            
                            // Show Santa figures and greeting
                            santa1.visible = true;
                            santa2.visible = true;

                            statusElement.textContent = "Status: Christmas blessing delivered!";
                            messageOverlay.textContent = currentGreetingText;
                            messageOverlay.classList.add('centered-greeting');
                            messageOverlay.style.opacity = 1.0; 
                            resetButton.classList.add('visible');
                    }
                    
                    christmasTree.geometry.attributes.position.needsUpdate = true;
                }
            }

            // 5. Tree rotation and movement (Idle / Tracking state)
            if (appState === STATES.TRACKING || appState === STATES.OK_HOLDING) {
                // Apply smoothed rotation from hand control
                let diff = smoothedTargetAngle - christmasTree.rotation.y;
                while (diff > Math.PI) diff -= 2 * Math.PI;
                while (diff < -Math.PI) diff += 2 * Math.PI;
                christmasTree.rotation.y += diff * EASING_FACTOR; 

                christmasTree.rotation.y += 0.005; 

                // Apply position from hand control
                christmasTree.position.x += (smoothedTargetX - christmasTree.position.x) * EASING_FACTOR;
                const basePosY = 0.5;
                christmasTree.position.y += ((basePosY + smoothedTargetY) - christmasTree.position.y) * EASING_FACTOR;

                christmasTree.rotation.x = Math.sin(time * 0.8) * 0.1; 
                
                // NEW: Small-scale particle dispersion/gathering based on currentParticleDispersion
                if (christmasTree.visible) {
                    const positions = christmasTree.geometry.attributes.position.array;
                    
                    for (let i = 0; i < positions.length / 3; i++) {
                        const index3 = i * 3;
                        
                        const originalX = originalTreePositions[index3];
                        const originalY = originalTreePositions[index3 + 1];
                        const originalZ = originalTreePositions[index3 + 2];
                        
                        const randX = randomDisplacementVectors[index3];
                        const randY = randomDisplacementVectors[index3 + 1];
                        const randZ = randomDisplacementVectors[index3 + 2];

                        // Interpolate between original position (0.0) and max dispersed position (1.0)
                        positions[index3] = originalX + randX * currentParticleDispersion * MAX_LOCAL_DISPERSION_RADIUS;
                        positions[index3 + 1] = originalY + randY * currentParticleDispersion * MAX_LOCAL_DISPERSION_RADIUS;
                        positions[index3 + 2] = originalZ + randZ * currentParticleDispersion * MAX_LOCAL_DISPERSION_RADIUS;
                    }
                    christmasTree.geometry.attributes.position.needsUpdate = true;
                }

            } else if (appState === STATES.DISPERSING) {
                 christmasTree.rotation.y += 0.01; 
            } else if (appState === STATES.CARD_SHOWN) {
                 // Scene stationary
            }
            
            // 6. Message overlay fade-in during tracking state
            if (appState === STATES.TRACKING && parseFloat(messageOverlay.style.opacity) < 1.0) {
                 messageOverlay.style.opacity = Math.min(1.0, parseFloat(messageOverlay.style.opacity) + 0.05);
                 messageOverlay.classList.remove('centered-greeting');
            }

            renderer.render(scene, camera);
        }

        // --- MediaPipe Setup and Main Execution Flow ---
        
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
            }
        });
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.6
        });
        hands.onResults(onResults);

        const mpCamera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 640,
            height: 480
        });

        startButton.addEventListener('click', async () => {
            if (appState === STATES.INIT) {
                await Tone.start();
                setupMusic();

                initThree();
                animate();
                mpCamera.start(); 
                startButton.disabled = true;
                startButton.textContent = "Camera Enabled (Music Playing)";
                statusElement.textContent = "Status: Loading hand model...";

                videoElement.addEventListener('loadeddata', () => {
                    canvasElement.width = videoElement.videoWidth;
                    canvasElement.height = videoElement.videoHeight;
                    appState = STATES.TRACKING;
                    messageOverlay.textContent = "Make the 'OK' gesture in front of the camera to unlock your Christmas blessing! Open your hand to disperse particles, make a fist to gather them.";
                    messageOverlay.style.opacity = 1; 
                    statusElement.textContent = "Status: Tracking... Please make the OK gesture, or use your hand to spread/gather the particles.";
                });
            }
        });

        resetButton.addEventListener('click', resetScene);
        
        const clock = new THREE.Clock();
        messageOverlay.style.opacity = 0;

    </script>
</body>
</html>